/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var T=Object.create;var b=Object.defineProperty;var U=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var B=Object.getPrototypeOf,V=Object.prototype.hasOwnProperty;var R=(d,r)=>{for(var e in r)b(d,e,{get:r[e],enumerable:!0})},P=(d,r,e,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let s of A(r))!V.call(d,s)&&s!==e&&b(d,s,{get:()=>r[s],enumerable:!(t=U(r,s))||t.enumerable});return d};var N=(d,r,e)=>(e=d!=null?T(B(d)):{},P(r||!d||!d.__esModule?b(e,"default",{value:d,enumerable:!0}):e,d)),I=d=>P(b({},"__esModule",{value:!0}),d);var z={};R(z,{default:()=>F});module.exports=I(z);var c=require("obsidian");var u=require("obsidian"),v="local-chat-view",y=class extends u.ItemView{constructor(e,t){super(e);this.knownUsers=new Map;this.plugin=t}getViewType(){return v}getDisplayText(){return"\u041B\u043E\u043A\u0430\u043B\u044C\u043D\u0438\u0439 \u0427\u0430\u0442"}getIcon(){return"message-circle"}async onOpen(){let e=this.containerEl.children[1];e.empty(),e.addClass("local-chat-view-container");let t=e.createDiv({cls:"chat-sidebar"});t.createEl("h5",{text:"\u041E\u043D\u043B\u0430\u0439\u043D:",cls:"chat-user-list-header"}),this.userListEl=t.createDiv({cls:"chat-user-list"});let s=e.createDiv({cls:"chat-main-area"});this.messageContainerEl=s.createDiv({cls:"chat-message-area"}),this.messageContainerEl.id="chat-message-area-id";let i=s.createDiv({cls:"chat-input-area"});this.inputEl=i.createEl("input",{type:"text",placeholder:"\u0412\u0432\u0435\u0434\u0456\u0442\u044C \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F...",cls:"chat-input"}),this.sendButtonEl=i.createEl("button",{cls:"chat-send-button"}),(0,u.setIcon)(this.sendButtonEl,"send-horizontal"),this.sendButtonEl.setAttribute("aria-label","\u041D\u0430\u0434\u0456\u0441\u043B\u0430\u0442\u0438"),this.fileButtonEl=i.createEl("button",{cls:"chat-file-button"}),(0,u.setIcon)(this.fileButtonEl,"paperclip"),this.fileButtonEl.setAttribute("aria-label","\u041D\u0430\u0434\u0456\u0441\u043B\u0430\u0442\u0438 \u0444\u0430\u0439\u043B"),this.fileButtonEl.onClickEvent(this.handleSendFileClick.bind(this)),this.inputEl.addEventListener("keydown",a=>{a.key==="Enter"&&!a.shiftKey&&(a.preventDefault(),this.handleSendMessage())}),this.sendButtonEl.addEventListener("click",()=>{this.handleSendMessage()}),console.log(`[${this.plugin.manifest.name}] ChatView \u0432\u0456\u0434\u043A\u0440\u0438\u0442\u043E`),this.inputEl.focus()}handleSendFileClick(){let e=createEl("input",{type:"file"});e.onchange=async t=>{if(!e.files||e.files.length===0)return;let s=null;for(let i=0;i<e.files.length;i++){let a=e.files[i];console.log(`\u041E\u0431\u0440\u0430\u043D\u043E \u0444\u0430\u0439\u043B: ${a.name}, \u0440\u043E\u0437\u043C\u0456\u0440: ${a.size}`),await this.plugin.initiateSendFile(a,s)}e.value=""},e.click()}async onClose(){console.log(`[${this.plugin.manifest.name}] ChatView \u0437\u0430\u043A\u0440\u0438\u0442\u043E`)}handleSendMessage(){let e=this.inputEl.value.trim();if(e)try{this.plugin.sendMessage(null,e),this.inputEl.value="",this.inputEl.focus()}catch(t){console.error(`[${this.plugin.manifest.name}] \u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043D\u0430\u0434\u0441\u0438\u043B\u0430\u043D\u043D\u044F \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F:`,t),new u.Notice("\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043D\u0430\u0434\u0441\u0438\u043B\u0430\u043D\u043D\u044F \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u043D\u044F.")}}displayMessage(e,t,s,i){let a=this.messageContainerEl.createDiv({cls:`chat-message ${i?"own-message":"other-message"}`}),n=a.createDiv({cls:"message-header"});n.createSpan({cls:"message-sender",text:i?"\u0412\u0438":e}),n.createSpan({cls:"message-timestamp",text:new Date(s).toLocaleTimeString([],{hour:"2-digit",minute:"2-digit"})});let o=t.replace(/</g,"&lt;").replace(/>/g,"&gt;");a.createDiv({cls:"message-content"}).innerHTML=o,this.scrollToBottom()}addUserToList(e){if(this.knownUsers.has(e.nickname)){let i=this.knownUsers.get(e.nickname);i!=null&&i.element&&i.element.addClass("user-online");return}let t=this.userListEl.createDiv({cls:"chat-user-list-item user-online"});t.dataset.nickname=e.nickname;let s=t.createSpan({cls:"user-icon"});(0,u.setIcon)(s,"user"),t.createSpan({cls:"user-nickname",text:e.nickname}),this.knownUsers.set(e.nickname,{nickname:e.nickname,element:t})}removeUserFromList(e){var s;let t=this.knownUsers.get(e);(s=t==null?void 0:t.element)==null||s.remove(),this.knownUsers.delete(e)&&console.log(`[${this.plugin.manifest.name}] Removed user '${e}' from UI list.`)}clearUserList(){this.userListEl&&this.userListEl.empty(),this.knownUsers.clear(),console.log(`[${this.plugin.manifest.name}] Cleared user list in UI.`)}displayFileOffer(e,t){let s=this.messageContainerEl.createDiv({cls:"chat-message file-offer",attr:{"data-file-id":t.fileId}}),i=s.createDiv({cls:"message-header"});i.createSpan({cls:"message-sender",text:e}),i.createSpan({cls:"message-timestamp",text:new Date().toLocaleTimeString([],{hour:"2-digit",minute:"2-digit"})});let a=s.createDiv({cls:"message-content"});a.setText(`${e} \u043F\u0440\u043E\u043F\u043E\u043D\u0443\u0454 \u043D\u0430\u0434\u0456\u0441\u043B\u0430\u0442\u0438 \u0444\u0430\u0439\u043B: `),a.createEl("strong",{text:t.filename}),a.createSpan({text:` (${this.formatFileSize(t.size)})`});let n=s.createDiv({cls:"file-offer-actions"});n.createEl("button",{text:"\u041F\u0440\u0438\u0439\u043D\u044F\u0442\u0438"}).addEventListener("click",()=>{this.plugin.acceptFileOffer(e,t.fileId),this.updateFileProgress(t.fileId,"download",0,t.size,"accepted")}),n.createEl("button",{text:"\u0412\u0456\u0434\u0445\u0438\u043B\u0438\u0442\u0438",cls:"mod-danger"}).addEventListener("click",()=>{this.plugin.declineFileOffer(e,t.fileId),this.updateFileProgress(t.fileId,"download",0,t.size,"declined")}),this.scrollToBottom()}updateFileProgress(e,t,s,i,a){let n=this.messageContainerEl.querySelector(`.chat-message[data-file-id="${e}"]`);if(!n)if(t==="upload"){console.warn(`UI element for uploading file ${e} not implemented yet.`);return}else{console.warn(`Could not find message element for file transfer ${e} to update progress.`);return}let o=n.querySelector(".file-progress-container");if(!o){o=n.createDiv({cls:"file-progress-container"});let g=n.querySelector(".file-offer-actions");g&&g.empty()}o.empty();let l=i>0?Math.round(s/i*100):0,h=o.createEl("progress");h.max=i,h.value=s;let m=o.createSpan({cls:"progress-text"});switch(a){case"starting":m.setText(t==="download"?" \u0417\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0435\u043D\u043D\u044F \u043F\u043E\u0447\u0430\u043B\u043E\u0441\u044F... 0%":" \u0412\u0456\u0434\u043F\u0440\u0430\u0432\u043A\u0430 \u043F\u043E\u0447\u0430\u043B\u0430\u0441\u044F... 0%");break;case"progressing":m.setText(` ${l}% (${this.formatFileSize(s)} / ${this.formatFileSize(i)})`);break;case"completed":h.remove();let g=t==="download"?"\u0417\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0435\u043D\u043E \u0443\u0441\u043F\u0456\u0448\u043D\u043E.":"\u041D\u0430\u0434\u0456\u0441\u043B\u0430\u043D\u043E \u0443\u0441\u043F\u0456\u0448\u043D\u043E.";m.setText(` ${g} (${this.formatFileSize(i)})`),n.addClass("transfer-completed");break;case"error":h.remove(),m.setText(" \u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043F\u0435\u0440\u0435\u0434\u0430\u0447\u0456."),m.addClass("progress-error"),n.addClass("transfer-error");break;case"accepted":m.setText(" \u041F\u0440\u0438\u0439\u043D\u044F\u0442\u043E. \u041E\u0447\u0456\u043A\u0443\u0432\u0430\u043D\u043D\u044F \u0434\u0430\u043D\u0438\u0445..."),n.removeClass("offer-declined"),n.addClass("offer-accepted");break;case"declined":h.remove(),m.setText(" \u0412\u0456\u0434\u0445\u0438\u043B\u0435\u043D\u043E."),n.removeClass("offer-accepted"),n.addClass("offer-declined");break}this.scrollToBottom()}formatFileSize(e){if(e===0)return"0 Bytes";let t=1024,s=["Bytes","KB","MB","GB","TB"],i=Math.floor(Math.log(e)/Math.log(t));return parseFloat((e/Math.pow(t,i)).toFixed(2))+" "+s[i]}scrollToBottom(){setTimeout(()=>{this.messageContainerEl.scrollTop=this.messageContainerEl.scrollHeight},50)}displayUploadProgress(e){let t=this.messageContainerEl.createDiv({cls:"chat-message own-message file-upload",attr:{"data-file-id":e.fileId}}),s=t.createDiv({cls:"message-header"});s.createSpan({cls:"message-sender",text:"\u0412\u0438"}),s.createSpan({cls:"message-timestamp",text:new Date().toLocaleTimeString([],{hour:"2-digit",minute:"2-digit"})});let i=t.createDiv({cls:"message-content"});i.setText("\u041D\u0430\u0434\u0441\u0438\u043B\u0430\u043D\u043D\u044F \u0444\u0430\u0439\u043B\u0443: "),i.createEl("strong",{text:e.filename}),i.createSpan({text:` (${this.formatFileSize(e.size)})`}),e.recipientNickname&&i.createSpan({text:` \u0434\u043E ${e.recipientNickname}`}),t.createDiv({cls:"file-progress-container"}),this.updateFileProgress(e.fileId,"upload",0,e.size,"starting"),this.scrollToBottom()}};var $=require("ws"),C=class{constructor(r,e,t,s){this.wss=null;this.clients=new Map;this.clientsByNickname=new Map;this.port=r,this.serverNickname=e,this.callbacks=t,this.WSServerConstructor=s,console.log(`[WSServer] Initialized for server nickname: ${this.serverNickname}`)}start(){return new Promise((r,e)=>{if(this.wss){console.warn("[WSServer] Server already started."),r();return}try{console.log(`[WSServer] Starting server on port ${this.port}...`),this.wss=new this.WSServerConstructor({port:this.port}),this.wss.on("listening",()=>{console.log(`[WSServer] Successfully listening on port ${this.port}.`),r()}),this.wss.on("error",t=>{console.error("[WSServer] Server error:",t),this.callbacks.onError(t),this.wss=null,e(t)}),this.wss.on("connection",t=>{this._handleConnection(t)})}catch(t){console.error("[WSServer] Failed to create WebSocketServer:",t),this.callbacks.onError(t),e(t)}})}async stop(){return new Promise(r=>{if(!this.wss){r();return}console.log("[WSServer] Stopping server..."),this.clients.forEach(e=>{e.ws.terminate()}),this.clients.clear(),this.clientsByNickname.clear(),this.wss.close(e=>{e?(console.error("[WSServer] Error closing server:",e),this.callbacks.onError(e)):console.log("[WSServer] Server closed successfully."),this.wss=null,r()})})}_handleConnection(r){let e=`client_${Date.now()}_${Math.random().toString(36).substring(2,7)}`;console.log(`[WSServer] Client connected with temporary ID: ${e}. Waiting for identification.`);let t={id:e,nickname:"",ws:r};this.clients.set(r,t),r.on("message",s=>{this._handleMessage(r,s)}),r.on("close",(s,i)=>{console.log(`[WSServer] Client connection closed. Code: ${s}, Reason: ${i.toString()}`),this._handleCloseOrError(r)}),r.on("error",s=>{console.error(`[WSServer] WebSocket error for client ${t.nickname||t.id}:`,s),this._handleCloseOrError(r,s)})}_handleMessage(r,e){let t=this.clients.get(r);if(!t){console.warn("[WSServer] Message from unknown client socket.");return}let s;try{s=JSON.parse(e.toString("utf-8"))}catch(i){console.warn(`[WSServer] Received non-JSON message from ${t.nickname||t.id}:`,e),r.send(JSON.stringify({type:"error",message:"Invalid message format (not JSON)."}));return}if(!t.nickname){if(s.type==="identify"){let i=s;if(i.nickname&&typeof i.nickname=="string"){let a=i.nickname.trim();if(!a){console.warn(`[WSServer] Received 'identify' with empty nickname from ${t.id}. Disconnecting.`),r.send(JSON.stringify({type:"error",message:"Nickname cannot be empty."})),r.terminate(),this.clients.delete(r);return}if(this.clientsByNickname.has(a)){console.warn(`[WSServer] Nickname '${a}' already taken. Disconnecting client ${t.id}.`),r.send(JSON.stringify({type:"error",message:"Nickname already taken."})),r.terminate(),this.clients.delete(r);return}t.nickname=a,this.clientsByNickname.set(t.nickname,r),console.log(`[WSServer] Client identified: ID=${t.id}, Nickname='${t.nickname}'`),this.callbacks.onClientConnected(t.id,t.nickname)}else console.warn(`[WSServer] Received invalid 'identify' message (missing/invalid nickname) from ${t.id}. Disconnecting.`),r.send(JSON.stringify({type:"error",message:"Invalid identification payload (missing nickname)."})),r.terminate(),this.clients.delete(r)}else console.warn(`[WSServer] Received invalid first message type '${s.type}' from ${t.id}. Disconnecting.`),r.send(JSON.stringify({type:"error",message:"Identification required as first message."})),r.terminate(),this.clients.delete(r);return}s.senderNickname||(s.senderNickname=t.nickname),this.callbacks.onMessage(t.id,t.nickname,s)}_handleCloseOrError(r,e){let t=this.clients.get(r);t&&(this.clients.delete(r),t.nickname?(this.clientsByNickname.delete(t.nickname),console.log(`[WSServer] Client '${t.nickname}' (ID: ${t.id}) disconnected.`),this.callbacks.onClientDisconnected(t.id,t.nickname)):console.log(`[WSServer] Unidentified client (ID: ${t.id}) disconnected.`))}broadcast(r,e){let t=JSON.stringify(e);this.clients.forEach(s=>{if(s.ws.readyState===$.WebSocket.OPEN&&s.id!==r)try{s.ws.send(t)}catch(i){console.error(`[WSServer] Failed to broadcast to ${s.nickname||s.id}:`,i)}})}sendToClient(r,e){let t=null;for(let[s,i]of this.clients.entries())if(i.id===r){t=s;break}if(t&&t.readyState===$.WebSocket.OPEN)try{return t.send(JSON.stringify(e)),!0}catch(s){return console.error(`[WSServer] Failed to send message to client ID ${r}:`,s),this._handleCloseOrError(t,s),!1}return!1}sendToClientByNickname(r,e){let t=this.clientsByNickname.get(r);if(t&&t.readyState===$.WebSocket.OPEN)try{return t.send(JSON.stringify(e)),!0}catch(s){return console.error(`[WSServer] Failed to send message to client '${r}':`,s),this._handleCloseOrError(t,s),!1}return console.warn(`[WSServer] Client with nickname '${r}' not found for sending message.`),!1}findClientIdByNickname(r){var t;let e=this.clientsByNickname.get(r);return e&&((t=this.clients.get(e))==null?void 0:t.id)||null}handleLocalMessage(r,e){r.senderNickname!==this.serverNickname&&(console.warn(`[WSServer] handleLocalMessage: Payload sender '${r.senderNickname}' differs from server nickname '${this.serverNickname}'. Correcting.`),r.senderNickname=this.serverNickname),console.log(`[WSServer] Handling local message (Type: ${r.type}, To: ${e!=null?e:"broadcast"})`),this.callbacks.onMessage("local_server",this.serverNickname,r),e===null?(console.log(`[WSServer] Broadcasting local message type ${r.type}`),this.broadcast(null,r)):e===this.serverNickname?console.log(`[WSServer] Local message addressed to self (${e}), already handled.`):(console.log(`[WSServer] Sending local message privately to ${e}`),this.sendToClientByNickname(e,r)||console.warn(`[WSServer] Failed to send local private message: Recipient '${e}' not found or disconnected.`))}};var L=require("obsidian"),M=class{constructor(r){this.socket=null;this.serverAddress=null;this.isConnected=!1;this.reconnectAttempts=0;this.maxReconnectAttempts=5;this.reconnectDelay=5e3;this.requestedNickname=null;this.callbacks=r}connect(r,e){if(this.socket&&(this.socket.readyState===WebSocket.CONNECTING||this.socket.readyState===WebSocket.OPEN)){console.warn(`[WSClient] Already connected or connecting to ${this.serverAddress}.`);return}if(!r){console.error("[WSClient] Cannot connect: Server address is empty.");return}this.serverAddress=r,this.requestedNickname=e,this.isConnected=!1,console.log(`[WSClient] Attempting to connect to ${this.serverAddress}...`);try{this.socket=new WebSocket(this.serverAddress),this.socket.onopen=t=>this._handleOpen(t),this.socket.onmessage=t=>this._handleMessage(t),this.socket.onerror=t=>this._handleError(t),this.socket.onclose=t=>this._handleClose(t)}catch(t){console.error(`[WSClient] Error creating WebSocket connection to ${this.serverAddress}:`,t),this.callbacks.onError(t),this.socket=null}}disconnect(){this.socket&&(console.log(`[WSClient] Disconnecting from ${this.serverAddress}...`),this.reconnectAttempts=this.maxReconnectAttempts+1,this.socket.close(1e3,"Client disconnecting normally")),this.socket=null,this.isConnected=!1,this.serverAddress=null,this.requestedNickname=null}async sendMessage(r){return new Promise((e,t)=>{if(!this.isConnected||!this.socket||this.socket.readyState!==WebSocket.OPEN){console.warn("[WSClient] Cannot send message: Not connected."),t(new Error("WebSocket is not connected."));return}try{this.socket.send(JSON.stringify(r)),e()}catch(s){console.error("[WSClient] Error sending message:",s),this.callbacks.onError(s),t(s)}})}_handleOpen(r){if(console.log(`[WSClient] Connection opened successfully to ${this.serverAddress}`),this.isConnected=!0,this.reconnectAttempts=0,this.requestedNickname){let e={type:"identify",nickname:this.requestedNickname};console.log("[WSClient] Sending identification:",e),this.sendMessage(e).catch(t=>{console.error("[WSClient] Failed to send identification message:",t)})}else{console.error("[WSClient] Cannot identify: Nickname was not provided during connect."),this.disconnect();return}this.callbacks.onOpen(r)}_handleMessage(r){if(typeof r.data=="string")try{let e=JSON.parse(r.data);this.callbacks.onMessage(e)}catch(e){console.error("[WSClient] Received non-JSON text message or parse error:",r.data,e)}else r.data instanceof ArrayBuffer?console.log(`[WSClient] Received binary message (ArrayBuffer), ${r.data.byteLength} bytes.`):r.data instanceof Blob?console.log(`[WSClient] Received binary message (Blob), ${r.data.size} bytes.`):console.warn("[WSClient] Received message with unknown data type:",r.data)}_handleError(r){console.error("[WSClient] WebSocket error:",r),this.isConnected=!1,this.callbacks.onError(r)}_handleClose(r){if(console.warn(`[WSClient] WebSocket closed. Code: ${r.code}, Reason: '${r.reason}', Clean: ${r.wasClean}`),this.isConnected=!1,this.socket=null,this.callbacks.onClose(r),r.code!==1e3&&this.reconnectAttempts<this.maxReconnectAttempts){this.reconnectAttempts++;let e=this.reconnectDelay*Math.pow(1.5,this.reconnectAttempts-1);console.log(`[WSClient] Attempting reconnect #${this.reconnectAttempts} in ${e/1e3}s...`),setTimeout(()=>{this.serverAddress&&this.requestedNickname?this.connect(this.serverAddress,this.requestedNickname):console.log("[WSClient] Cannot reconnect: connection info missing.")},e)}else r.code!==1e3&&(console.error(`[WSClient] Max reconnect attempts (${this.maxReconnectAttempts}) reached. Giving up.`),new L.Notice("Failed to reconnect to chat server.",1e4))}};var S={role:"client",serverAddress:"ws://127.0.0.1:61338",serverPort:61338,userNickname:`ObsidianUser_${Math.random().toString(36).substring(2,8)}`,saveHistory:!0,downloadPath:""};var f=require("obsidian");var E=class extends f.PluginSettingTab{constructor(e,t){super(e,t);this.plugin=t}display(){let{containerEl:e}=this;e.empty(),e.createEl("h2",{text:"Local Chat Settings"}),new f.Setting(e).setName("Instance Role").setDesc("Client connects to a server. Server accepts connections (Desktop Only). Restart required.").addDropdown(i=>{if(i.addOption("client","Client").addOption("server","Server").setValue(this.plugin.settings.role).onChange(async a=>{if(f.Platform.isMobile&&a==="server"){new f.Notice("Server role not supported on mobile."),i.setValue("client");return}this.plugin.settings.role!==a&&(this.plugin.settings.role=a,await this.plugin.saveSettings(),this.display(),new f.Notice("Role changed. Restart Obsidian for changes to take effect.",7e3))}),f.Platform.isMobile){let a=i.selectEl.querySelector('option[value="server"]');a&&(a.disabled=!0),this.plugin.settings.role==="server"&&i.setValue("client")}});let t=new f.Setting(e).setName("Server Address").setDesc("WebSocket address (e.g., ws://192.168.1.100:61338)").addText(i=>i.setPlaceholder(S.serverAddress).setValue(this.plugin.settings.serverAddress).onChange(async a=>{this.plugin.settings.serverAddress=(a==null?void 0:a.trim())||S.serverAddress,await this.plugin.saveSettings()})),s=new f.Setting(e).setName("Server Port").setDesc("Port for the server to listen on. Restart required.").addText(i=>i.setPlaceholder(String(S.serverPort)).setValue(String(this.plugin.settings.serverPort)).onChange(async a=>{let n=parseInt(a),o=!1;!isNaN(n)&&n>1024&&n<65535?this.plugin.settings.serverPort!==n&&(this.plugin.settings.serverPort=n,o=!0):a!==String(this.plugin.settings.serverPort)&&(i.setValue(String(this.plugin.settings.serverPort)),new f.Notice("Invalid port (1025-65534).")),o&&(await this.plugin.saveSettings(),new f.Notice("Server port changed. Restart Obsidian to apply.",7e3))}));this.plugin.settings.role==="server"&&!f.Platform.isMobile?(t.settingEl.style.display="none",s.settingEl.style.display=""):(t.settingEl.style.display="",s.settingEl.style.display="none"),new f.Setting(e).setName("Your Nickname").setDesc("How you appear to others.").addText(i=>i.setPlaceholder(S.userNickname).setValue(this.plugin.settings.userNickname).onChange(async a=>{let n=(a==null?void 0:a.trim())||S.userNickname;this.plugin.settings.userNickname!==n&&(this.plugin.settings.userNickname=n,await this.plugin.saveSettings())})),new f.Setting(e).setName("Download Folder").setDesc("Relative to vault root. Leave empty for vault attachment folder.").addText(i=>{let a="Default: Vault attachment folder";try{let n=this.app.vault.getConfig("attachmentFolderPath");n&&typeof n=="string"&&n.trim()&&(a=n.trim())}catch(n){console.warn("[Local Chat Settings] Could not read attachment folder path for placeholder:",n)}i.setPlaceholder(a).setValue(this.plugin.settings.downloadPath).onChange(async n=>{var o;this.plugin.settings.downloadPath=(o=n==null?void 0:n.trim())!=null?o:"",await this.plugin.saveSettings()})}),new f.Setting(e).setName("Save Chat History").setDesc("Keep messages between sessions.").addToggle(i=>i.setValue(this.plugin.settings.saveHistory).onChange(async a=>{this.plugin.settings.saveHistory=a,await this.plugin.saveSettings()}))}};var D=require("ws"),x=N(require("fs")),p=N(require("path")),F=class extends c.Plugin{constructor(){super(...arguments);this.chatView=null;this.webSocketClientManager=null;this.webSocketServerManager=null;this.outgoingFileOffers=new Map;this.incomingFileOffers=new Map;this.knownUsers=new Map}async onload(){let e=`[${this.manifest.name}]`;console.log(`${e} Loading plugin...`),await this.loadSettings(),console.log(`${e} Role: ${this.settings.role}. Nickname: ${this.settings.userNickname}.`);let t=this.createClientCallbacks(),s=this.createServerCallbacks();if(this.settings.role==="server")if(c.Platform.isMobile)new c.Notice("Error: 'Server' role is not supported on mobile. Please change in settings.",1e4),console.error(`${e} Cannot start in server mode on mobile.`);else{console.log(`${e} Initializing in SERVER mode on port ${this.settings.serverPort}...`);try{this.webSocketServerManager=new C(this.settings.serverPort,this.settings.userNickname,s,D.WebSocketServer),await this.webSocketServerManager.start(),this.handleUserFound({nickname:this.settings.userNickname}),new c.Notice(`${this.manifest.name}: Server started on port ${this.settings.serverPort}.`)}catch(i){console.error(`${e} CRITICAL ERROR starting WebSocket server:`,i),new c.Notice(`[${this.manifest.name}] Failed to start server! Error: ${i.message}.`,1e4),this.webSocketServerManager=null}}else console.log(`${e} Initializing in CLIENT mode. Connecting to ${this.settings.serverAddress}...`),!this.settings.serverAddress||!this.settings.serverAddress.toLowerCase().startsWith("ws")?(new c.Notice(`[${this.manifest.name}] Invalid server address: "${this.settings.serverAddress}". Check settings.`,1e4),console.error(`${e} Invalid server address.`)):(this.webSocketClientManager=new M(t),this.webSocketClientManager.connect(this.settings.serverAddress,this.settings.userNickname));this.registerView(v,i=>(this.chatView=new y(i,this),this.populateInitialChatViewState(),this.chatView)),this.addRibbonIcon("message-circle","Open Local Chat",()=>this.activateView()),this.addCommand({id:"open-local-chat-view",name:"Open Local Chat panel",callback:()=>this.activateView()}),this.addSettingTab(new E(this.app,this)),console.log(`${e} Plugin UI initialized.`)}async onunload(){console.log(`[${this.manifest.name}] Unloading plugin...`),await this.cleanupNetworkServices(),this.app.workspace.detachLeavesOfType(v),this.chatView=null,this.outgoingFileOffers.clear(),this.incomingFileOffers.clear(),this.knownUsers.clear(),console.log(`[${this.manifest.name}] Plugin unloaded.`)}populateInitialChatViewState(){this.chatView&&this.knownUsers.forEach(e=>{var t;return(t=this.chatView)==null?void 0:t.addUserToList(e)})}async cleanupNetworkServices(){if(this.webSocketClientManager&&(this.webSocketClientManager.disconnect(),this.webSocketClientManager=null,console.log(`[${this.manifest.name}] WebSocket client disconnected.`)),this.webSocketServerManager){try{await this.webSocketServerManager.stop(),console.log(`[${this.manifest.name}] WebSocket server stopped.`)}catch(e){console.error(`[${this.manifest.name}] Error stopping WebSocket server:`,e)}this.webSocketServerManager=null}}createClientCallbacks(){return{onOpen:()=>{console.log(`[${this.manifest.name}] Client: Connected.`),new c.Notice("Chat connected.",3e3)},onClose:e=>{var t,s;console.warn(`[${this.manifest.name}] Client: Disconnected. Code: ${e.code}`),new c.Notice("Chat disconnected.",5e3),this.knownUsers.clear(),(s=(t=this.chatView)==null?void 0:t.clearUserList)==null||s.call(t)},onError:e=>{console.error(`[${this.manifest.name}] Client: WebSocket Error`,e),new c.Notice("Chat connection error.",5e3)},onMessage:e=>{console.debug(`[${this.manifest.name}] Client: Received message`,e),this.handleServerMessage(e)}}}createServerCallbacks(){return{onClientConnected:(e,t)=>{var a;console.log(`[${this.manifest.name}] Server: Client '${t}' connected (ID: ${e})`);let s={nickname:t};this.handleUserFound(s);let i={type:"userList",users:this.getAllUsers(),timestamp:Date.now()};(a=this.webSocketServerManager)==null||a.sendToClient(e,i)},onClientDisconnected:(e,t)=>{console.log(`[${this.manifest.name}] Server: Client '${t}' disconnected (ID: ${e})`),this.handleUserLeft({nickname:t})},onMessage:(e,t,s)=>{console.debug(`[${this.manifest.name}] Server: Message from '${t}' (ID: ${e})`,s),this.handleClientMessage(e,t,s)},onError:e=>{console.error(`[${this.manifest.name}] Server: Error`,e),new c.Notice(`Chat Server Error: ${e.message}`,5e3)}}}handleServerMessage(e){var t,s,i,a;switch(e.type){case"text":{let n=e,o=n.senderNickname||"Unknown";console.log(`[${this.manifest.name}] Handling incoming text from ${o}`),(t=this.chatView)==null||t.displayMessage(o,n.content,n.timestamp||Date.now(),!1);break}case"fileOffer":{let n=e,o=n.senderNickname||"Unknown";console.log(`[${this.manifest.name}] Handling incoming fileOffer from ${o}`),this.incomingFileOffers.set(n.fileId,{...n,senderNickname:o}),(s=this.chatView)==null||s.displayFileOffer(o,n),this.isChatViewActive()||new c.Notice(`File offer '${n.filename}' from ${o}`);break}case"fileAccept":{let n=e;console.log(`[${this.manifest.name}] Handling incoming fileAccept for ${n.fileId} from ${n.senderNickname}`),this.handleRemoteFileAccept(n.fileId,n.senderNickname);break}case"fileDecline":{let n=e;console.log(`[${this.manifest.name}] Handling incoming fileDecline for ${n.fileId} from ${n.senderNickname}`),this.handleRemoteFileDecline(n.fileId,n.senderNickname);break}case"userList":{let n=e;console.log(`[${this.manifest.name}] Received user list from server`,n.users),this.knownUsers.clear(),n.users.forEach(o=>this.knownUsers.set(o.nickname,o)),(a=(i=this.chatView)==null?void 0:i.clearUserList)==null||a.call(i),this.knownUsers.forEach(o=>{var l;return(l=this.chatView)==null?void 0:l.addUserToList(o)});break}case"userJoin":{let n=e;console.log(`[${this.manifest.name}] User joined: ${n.nickname}`),this.handleUserFound({nickname:n.nickname});break}case"userLeave":{let n=e;console.log(`[${this.manifest.name}] User left: ${n.nickname}`),this.handleUserLeft({nickname:n.nickname});break}default:console.warn(`[${this.manifest.name}] Received unhandled message type from server:`,e.type)}}handleClientMessage(e,t,s){var i,a;if(this.webSocketServerManager)switch(s.senderNickname&&s.senderNickname!==t&&console.warn(`[${this.manifest.name}] Message senderNickname mismatch from client ${e}. Claimed: '${s.senderNickname}', Actual: '${t}'. Using actual.`),s.senderNickname=t,s.type){case"text":{let n=s;console.log(`[${this.manifest.name}] Broadcasting text from ${t}`),this.webSocketServerManager.broadcast(e,n),(i=this.chatView)==null||i.displayMessage(n.senderNickname,n.content,n.timestamp||Date.now(),!1);break}case"fileOffer":{let n=s,o=n.recipient;o?(console.log(`[${this.manifest.name}] Relaying private fileOffer from ${t} to ${o}`),this.webSocketServerManager.sendToClientByNickname(o,n)||console.warn(`[${this.manifest.name}] Recipient ${o} not found for file offer relay.`)):(console.log(`[${this.manifest.name}] Broadcasting fileOffer from ${t}`),this.webSocketServerManager.broadcast(e,n),this.incomingFileOffers.set(n.fileId,{...n,senderNickname:t,senderClientId:e}),(a=this.chatView)==null||a.displayFileOffer(t,n));break}case"fileAccept":case"fileDecline":{let n=s,o=n.originalSender;o?(console.log(`[${this.manifest.name}] Relaying ${n.type} for ${n.fileId} from ${t} to original sender ${o}`),this.webSocketServerManager.sendToClientByNickname(o,n)||console.warn(`[${this.manifest.name}] Cannot relay ${n.type}: Original sender ${o} not found.`)):console.warn(`[${this.manifest.name}] Cannot relay ${n.type}: Original sender not specified in message from ${t}.`,n);break}default:console.warn(`[${this.manifest.name}] Received unhandled message type from client ${t}:`,s.type)}}handleUserFound(e){var t;if(this.knownUsers.set(e.nickname,e),(t=this.chatView)==null||t.addUserToList(e),this.settings.role==="server"&&this.webSocketServerManager&&e.nickname!==this.settings.userNickname){let s={type:"userJoin",nickname:e.nickname,timestamp:Date.now()},i=this.webSocketServerManager.findClientIdByNickname(e.nickname);this.webSocketServerManager.broadcast(i,s)}}handleUserLeft(e){var t;if(this.knownUsers.delete(e.nickname)&&(console.log(`[${this.manifest.name}] User Left: ${e.nickname}`),(t=this.chatView)==null||t.removeUserFromList(e.nickname),this.settings.role==="server"&&this.webSocketServerManager)){let s={type:"userLeave",nickname:e.nickname,timestamp:Date.now()};this.webSocketServerManager.broadcast(null,s)}}getAllUsers(){return Array.from(this.knownUsers.values())}async sendMessage(e,t){var l;let s=this.settings.userNickname;if(!(t!=null&&t.trim()))return;let i=t.trim(),a=Date.now();(l=this.chatView)==null||l.displayMessage(s,i,a,!0);let n={type:"text",senderNickname:s,content:i,timestamp:a,recipient:e},o=null;try{if(this.settings.role==="client"&&this.webSocketClientManager)await this.webSocketClientManager.sendMessage(n);else if(this.settings.role==="server"&&this.webSocketServerManager)this.webSocketServerManager.handleLocalMessage(n,e);else throw new Error("Chat service not configured or active.")}catch(h){console.error(`[${this.manifest.name}] Error sending message:`,h),o=`Send Error: ${h.message}`}o&&new c.Notice(o)}async initiateSendFile(e,t){var W,k,O;let s=`[${this.manifest.name}]`;if(!(this.settings.role==="client"?this.webSocketClientManager:this.webSocketServerManager)){new c.Notice("Chat service is not ready to send files."),console.error(`${s} initiateSendFile: No active WebSocket manager.`);return}if(t!==null){new c.Notice("User discovery service not ready for private file offer."),console.warn(`${s} initiateSendFile: UserDiscovery needed for private offer to ${t}`);return}let a=`file_${Date.now()}_${Math.random().toString(36).substring(2,9)}`,n=e.name,o=e.size,l=e.path;if(!l||typeof l!="string"){let w="Error: Could not determine file path. File sending may require copying the file first (feature not fully implemented).";new c.Notice(w,1e4),console.error(`${s} initiateSendFile: Failed to determine file path for '${n}'. '.path' property is unreliable.`);return}console.warn(`${s} initiateSendFile: Using potentially unreliable file path: ${l}`);let h={fileId:a,filePath:l,filename:n,size:o,recipientNickname:t};this.outgoingFileOffers.set(a,h),console.log(`${s} Stored outgoing file offer: ${n} (ID: ${a})`),(W=this.chatView)==null||W.displayUploadProgress({fileId:a,filename:n,size:o,recipientNickname:t});let m={type:"fileOffer",senderNickname:this.settings.userNickname,fileId:a,filename:n,size:o,recipient:t,timestamp:Date.now()},g=null;try{if(console.log(`${s} Sending fileOffer ${a} (To: ${t!=null?t:"broadcast"})...`),this.settings.role==="client"){if(!this.webSocketClientManager)throw new Error("Client manager not available.");await this.webSocketClientManager.sendMessage(m)}else{if(!this.webSocketServerManager)throw new Error("Server manager not available.");this.webSocketServerManager.handleLocalMessage(m,t)}console.log(`${s} File offer ${a} sent successfully.`)}catch(w){console.error(`${s} Error sending fileOffer for ${a}:`,w),g=`Error sending file offer: ${w.message}`,this.outgoingFileOffers.delete(a),(O=(k=this.chatView)==null?void 0:k.updateFileProgress)==null||O.call(k,a,"upload",0,o,"error")}g&&new c.Notice(g)}async acceptFileOffer(e,t){var n,o,l,h;let s=this.incomingFileOffers.get(t);if(!s){new c.Notice("Error: File offer not found or already handled.");return}console.log(`[${this.manifest.name}] Accepting file offer ${t} from ${e}`),(o=(n=this.chatView)==null?void 0:n.updateFileProgress)==null||o.call(n,t,"download",0,s.size,"accepted");let i={type:"fileAccept",senderNickname:this.settings.userNickname,fileId:t,originalSender:e,timestamp:Date.now()},a=null;try{if(this.settings.role==="client"&&this.webSocketClientManager)await this.webSocketClientManager.sendMessage(i);else if(this.settings.role==="server"&&this.webSocketServerManager){if(!this.webSocketServerManager.sendToClientByNickname(e,i))throw new Error(`Cannot send acceptance, user ${e} not found.`)}else throw new Error("Chat service not configured or active.");console.log(`[${this.manifest.name}] File acceptance for ${t} sent.`)}catch(m){console.error(`[${this.manifest.name}] Error sending file acceptance for ${t}:`,m),a=`Error accepting file: ${m.message}`,this.incomingFileOffers.delete(t),(h=(l=this.chatView)==null?void 0:l.updateFileProgress)==null||h.call(l,t,"download",0,s.size,"error")}a&&new c.Notice(a)}async declineFileOffer(e,t){var a,n,o,l;let s=this.incomingFileOffers.get(t);if(!s){(n=(a=this.chatView)==null?void 0:a.updateFileProgress)==null||n.call(a,t,"download",0,0,"declined");return}console.log(`[${this.manifest.name}] Declining file offer ${t} from ${e}`),this.incomingFileOffers.delete(t),(l=(o=this.chatView)==null?void 0:o.updateFileProgress)==null||l.call(o,t,"download",0,s.size||0,"declined");let i={type:"fileDecline",senderNickname:this.settings.userNickname,fileId:t,originalSender:e,timestamp:Date.now()};try{this.settings.role==="client"&&this.webSocketClientManager?await this.webSocketClientManager.sendMessage(i):this.settings.role==="server"&&this.webSocketServerManager&&(this.webSocketServerManager.sendToClientByNickname(e,i)||console.warn(`[${this.manifest.name}] Cannot send decline, user ${e} not found.`)),console.log(`[${this.manifest.name}] Decline message for ${t} sent (or attempted).`)}catch(h){console.warn(`[${this.manifest.name}] Error sending file decline for ${t}: ${h.message}`)}}handleRemoteFileDecline(e,t){var i,a;let s=this.outgoingFileOffers.get(e);s?(console.log(`[${this.manifest.name}] User ${t} declined file ${s.filename} (ID: ${e})`),new c.Notice(`User ${t} declined file: ${s.filename}`),this.outgoingFileOffers.delete(e),(a=(i=this.chatView)==null?void 0:i.updateFileProgress)==null||a.call(i,e,"upload",0,s.size||0,"declined")):console.warn(`[${this.manifest.name}] Received remote fileDecline for unknown outgoing offer ID: ${e}`)}async handleRemoteFileAccept(e,t){var a,n,o,l;let s=this.outgoingFileOffers.get(e);if(!s){console.warn(`[${this.manifest.name}] Received acceptance for unknown outgoing offer ${e}`);return}if(console.log(`[${this.manifest.name}] User ${t} accepted file ${s.filename} (ID: ${e}). Preparing upload...`),!await this.adapterFileExists(s.filePath)){console.error(`[${this.manifest.name}] Cannot start upload for ${e}: File not accessible at path: ${s.filePath}.`),console.error("Reminder: The method to obtain 'filePath' in 'initiateSendFile' needs a proper implementation (e.g., copying the file)."),new c.Notice(`Error starting upload: Cannot access file ${s.filename}`),this.outgoingFileOffers.delete(e),(n=(a=this.chatView)==null?void 0:a.updateFileProgress)==null||n.call(a,e,"upload",0,s.size,"error");return}(l=(o=this.chatView)==null?void 0:o.updateFileProgress)==null||l.call(o,e,"upload",0,s.size,"starting"),console.error("<<<<< FILE UPLOAD STREAMING VIA WEBSOCKET IS NOT IMPLEMENTED >>>>>"),new c.Notice(`File upload streaming for ${s.filename} not implemented yet.`),setTimeout(()=>{console.warn(`[${this.manifest.name}] Placeholder: Simulating error for unimplemented upload of ${e}`),this.handleFileTransferError(e,"upload",new Error("File upload streaming not implemented"))},1500)}handleFileAcceptReceived(e,t){t.originalSender===this.settings.userNickname?(console.log(`[${this.manifest.name}] Handling fileAccept message from ${e.nickname} for our offer ${t.fileId}`),this.handleRemoteFileAccept(t.fileId,e.nickname)):console.warn(`[${this.manifest.name}] Received fileAccept message for an offer not originated by us. Original Sender: ${t.originalSender}, File ID: ${t.fileId}`)}handleFileTransferError(e,t,s){var n,o;console.error(`[${this.manifest.name}] File transfer error: ${e} (${t})`,s);let i=t==="upload"?this.outgoingFileOffers.get(e):this.incomingFileOffers.get(e),a=(i==null?void 0:i.filename)||"\u0444\u0430\u0439\u043B";new c.Notice(`\u041F\u043E\u043C\u0438\u043B\u043A\u0430 \u043F\u0435\u0440\u0435\u0434\u0430\u0447\u0456 \u0444\u0430\u0439\u043B\u0443 '${a}': ${s.message}`,7e3),t==="upload"?this.outgoingFileOffers.delete(e):this.incomingFileOffers.delete(e),(o=(n=this.chatView)==null?void 0:n.updateFileProgress)==null||o.call(n,e,t,0,0,"error")}async loadSettings(){this.settings=Object.assign({},S,await this.loadData())}async saveSettings(){await this.saveData(this.settings),console.log(`[${this.manifest.name}] Settings saved.`)}async activateView(){var i;let{workspace:e}=this.app,t=null,s=e.getLeavesOfType(v);if(s.length>0)t=s[0];else{let a=(i=e.getRightLeaf(!1))!=null?i:e.getLeftLeaf(!1);if(a)t=a,await t.setViewState({type:v,active:!0});else{console.error("Could not get a side leaf."),new c.Notice("Error opening chat panel.");return}}t?e.revealLeaf(t):console.error("Logic error in activateView: leafToReveal is unexpectedly null.")}isChatViewActive(){let e=this.app.workspace.activeLeaf;return!!e&&e.getViewState().type===v}async determineSavePath(e){var m;let t=((m=this.settings.downloadPath)==null?void 0:m.trim())||"";if(!t)try{let g=this.app.vault.getConfig("attachmentFolderPath");g&&typeof g=="string"?t=g.startsWith("/")?g.substring(1):g:t=""}catch(g){console.warn(`[${this.manifest.name}] Error reading attachment folder setting, using vault root.`,g),t=""}try{let g=this.app.vault.getAbstractFileByPath(t);g&&!(g instanceof c.TFolder)?(console.warn(`[${this.manifest.name}] Download path '${t}' is not a folder. Using vault root.`),t=""):!g&&t&&await this.app.vault.createFolder(t)}catch(g){console.error(`[${this.manifest.name}] Error ensuring download directory '${t}' exists. Using vault root.`,g),t=""}let s=this.app.vault.adapter;if(typeof s.getBasePath!="function")throw new Error("Cannot determine vault base path via adapter.");let i=p.join(s.getBasePath(),t),a=0,n=this.sanitizeFilename(e),o=n,l=p.join(i,o),h=100;for(;await this.adapterFileExists(l)&&a<h;){a++;let g=p.extname(n);o=`${p.basename(n,g)} (${a})${g}`,l=p.join(i,o)}if(a>=h)throw new Error(`Failed to find unique filename for ${e}`);return console.log(`[${this.manifest.name}] Determined save path: ${l}`),l}async adapterFileExists(e){try{let t=this.app.vault.adapter;if(typeof t.getBasePath!="function"||typeof t.stat!="function")return console.warn("[adapterFileExists] Adapter missing required methods, falling back to fs.existsSync"),x.existsSync(e);let s=t.getBasePath(),i=p.relative(s,e).replace(/\\/g,"/");return!i||i.startsWith("..")?(console.warn(`[adapterFileExists] Path outside vault? ${i}. Using fs.existsSync.`),x.existsSync(e)):!!await t.stat(i)}catch(t){return!1}}sanitizeFilename(e){let t=/[<>:"/\\|?*\x00-\x1F]/g,s=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,i=e.replace(t,"_");return s.test(i)&&(i=`_${i}`),(i.trim()||"downloaded_file").substring(0,200)}};
